import {
  UpdateType,
  ChannelUpdate,
  FullChannelState,
  IVectorStore,
  Result,
  IChannelSigner,
  UpdateParams,
  OutboundChannelUpdateError,
  InboundChannelUpdateError,
  IVectorChainReader,
  Values,
  DEFAULT_TRANSFER_TIMEOUT,
  FullTransferState,
  ChannelCommitmentData,
  ValidationError,
  CreateUpdateDetails,
  ResolveUpdateDetails,
  IExternalValidation,
  Balance,
} from "@connext/vector-types";
import { getSignerAddressFromPublicIdentifier } from "@connext/vector-utils";
import { BigNumber, constants } from "ethers";
import pino from "pino";

import { applyUpdate } from "./update";
import { generateSignedChannelCommitment, validateChannelUpdateSignatures } from "./utils";

// This function performs all update *initiator* side validation
// and is called from within the `sync.outbound` function.
// It will return the valid previous state, as well as the valid parameters.
// NOTE: the presence and validity of the values within the parameters should
// be asserted before the operation is put under lock via schema definitions.
type OutboundValidationResult<T extends UpdateType = any> = Result<
  {
    validParams: UpdateParams<T>;
    validState: FullChannelState;
    activeTransfers: FullTransferState[];
  },
  OutboundChannelUpdateError
>;

export async function validateOutbound<T extends UpdateType = any>(
  params: UpdateParams<T>,
  storeService: IVectorStore,
  externalValidation: IExternalValidation,
  signer: IChannelSigner,
): Promise<OutboundValidationResult<T>> {
  // Create a helper to handle errors
  const returnError = (
    validationError: Values<typeof ValidationError.reasons>,
    state?: FullChannelState,
    context: any = {},
  ): OutboundValidationResult => {
    return Result.fail(
      new OutboundChannelUpdateError(OutboundChannelUpdateError.reasons.OutboundValidationFailed, params, state, {
        error: validationError,
        ...context,
      }),
    );
  };

  // Grab the channel from the store
  let state = await storeService.getChannelState(params.channelAddress);

  // IFF it is a setup update, you should make sure that the channel does
  // not exist by channel address, then create an empty channel object.
  // Other setup validation will occur within `validateOutboundSetup`
  if (params.type === UpdateType.setup) {
    if (state) {
      return returnError(ValidationError.reasons.ChannelAlreadySetup);
    }
    // The parameters are valid by schema, safe to destructure
    const {
      channelAddress,
      details: { counterpartyIdentifier, networkContext },
    } = params as UpdateParams<typeof UpdateType.setup>;

    state = {
      nonce: 0,
      channelAddress,
      timeout: "0",
      alice: signer.address,
      bob: getSignerAddressFromPublicIdentifier(counterpartyIdentifier),
      balances: [],
      processedDepositsA: [],
      processedDepositsB: [],
      assetIds: [],
      merkleRoot: constants.HashZero,
      latestUpdate: {} as any,
      networkContext,
      aliceIdentifier: signer.publicIdentifier,
      bobIdentifier: counterpartyIdentifier,
      defundNonce: "1",
    };
  }

  // If the state is still undefined here, thow an error
  if (!state) {
    return returnError(ValidationError.reasons.ChannelNotFound);
  }

  // Get the active transfers for applying the update
  const activeTransfers = await storeService.getActiveTransfers(params.channelAddress);

  // When resolving, you will need the stored transfer for external validation
  let storedTransfer: FullTransferState | undefined = undefined;
  switch (params.type) {
    case UpdateType.setup: {
      // Setup param details include:
      // - timeout
      // - counterpartyIdentifier
      // - networkContext
      // There is no need to validate the `channelAddress` here because
      // it is generated by us using `create2MultisigAddress` within the
      // Vector file
      const {
        details: { networkContext, timeout },
      } = params as UpdateParams<typeof UpdateType.setup>;

      // Validate the channel does not already exist by participants
      const byCounterpartySameOrder = await storeService.getChannelStateByParticipants(
        state.alice,
        state.bob,
        networkContext.chainId,
      );
      const byCounterpartyDifferentOrder = await storeService.getChannelStateByParticipants(
        state.bob,
        state.alice,
        networkContext.chainId,
      );
      if (byCounterpartyDifferentOrder || byCounterpartySameOrder) {
        return returnError(ValidationError.reasons.ChannelAlreadySetup, state, {
          byCounterpartyDifferentOrder: byCounterpartyDifferentOrder?.channelAddress,
          byCounterpartySameOrder: byCounterpartySameOrder?.channelAddress,
        });
      }

      // Validate that the timeout is above the default
      if (BigNumber.from(timeout).lt(DEFAULT_TRANSFER_TIMEOUT)) {
        return returnError(ValidationError.reasons.SetupTimeoutInvalid, state, {
          timeout,
          minimumTimeout: DEFAULT_TRANSFER_TIMEOUT,
        });
      }

      // TODO: https://github.com/connext/vector/issues/51
      break;
    }
    case UpdateType.deposit: {
      // Deposit details include:
      // - channelAddress
      // - assetId
      // Both of these should be validated via the schemas. In the outbound
      // validation, there is nothing contextual to validate, since all of
      // the relevant update values are pulled from chain
      break;
    }
    case UpdateType.create: {
      // Create details include:
      // - amount
      // - assetId
      // - transferDefinition
      // - transferInitialState
      // - timeout
      // - encodings
      // - meta (optional)
      // The transferDefinition, assetId, and meta structures are
      // asserted by the schemas

      // Ensure amount === total locked in initial state

      // Ensure participants both have sufficient funds of asset
      // to create the transfer

      // Ensure the encodings will work properly for the state
      // TODO: https://github.com/connext/vector/issues/51

      // Ensure the timeout is above the minimum

      // Ensure the `balance` in the transfer initial state is okay
      // (valid addresses, valid amounts)
      break;
    }
    case UpdateType.resolve: {
      // Resolve details include:
      // - transferId
      // - transferResolver
      // - meta (optional)
      // The validity of the transferId and meta structures are
      // asserted by the schemas
      const {
        details: { transferId },
      } = params as UpdateParams<typeof UpdateType.resolve>;

      // Transfer should exist in store
      storedTransfer = await storeService.getTransferState(transferId);
      if (!storedTransfer) {
        return returnError(ValidationError.reasons.TransferNotFound, state);
      }

      // Transfer should exist in active transfers
      if (!activeTransfers.find(t => t.transferId === transferId)) {
        return returnError(ValidationError.reasons.TransferNotActive, state, {
          activeTransfers: activeTransfers.map(t => t.transferId).join(","),
        });
      }

      // Transfer resolver should match stored resolver encoding
      // NOTE: resolver encoding must be validated on create

      // Everything else is generated from chain, or pulled from
      // already validated items within the store

      // NOTE: any transfer-specific validation is OUT OF SCOPE
      // for this function, and must be injected by the vector
      // consumer on instantiation
      break;
    }
    default: {
      throw new Error(`Unexpected UpdateType in received params: ${params.type}`);
    }
  }

  // All default validation is performed, make call to external
  // validation service
  const externalRes = await externalValidation.validateOutbound(params, state, storedTransfer);
  if (externalRes.isError) {
    return returnError(ValidationError.reasons.ExternalValidationFailed, state, {
      validationError: externalRes.getError()!.message,
    });
  }

  return Result.ok({
    validParams: params,
    validState: state,
    activeTransfers,
  });
}

// This function performs all update validation when you are receiving
// a proposed update in `sync.inbound` and `sync.outbound` when you
// are behind and have proposed an update. It will validate + apply the
// update, returning the signed commitment and next state

// NOTE: NONE of the parameters here should be assumed valid, since
// this information is passed over the wire and is not validated
// using the defined schemas. Additionally, this function is called
// by `sync.inbound` (primarily), which is registered on a messaging
// callback.
type InboundValidationResult<T extends UpdateType = any> = Result<
  {
    validUpdate: ChannelUpdate<T>;
    nextState: FullChannelState<T>;
    commitment: ChannelCommitmentData;
    activeTransfers: FullTransferState[]; // after applyUpdate
    transfer?: FullTransferState; // after applyUpdate
  },
  InboundChannelUpdateError
>;
export async function validateAndApplyInboundUpdate<T extends UpdateType = any>(
  update: ChannelUpdate<T>,
  state: FullChannelState,
  storeService: IVectorStore,
  chainReader: IVectorChainReader,
  externalValidation: IExternalValidation,
  signer: IChannelSigner,
  logger: pino.BaseLogger = pino(),
): Promise<InboundValidationResult> {
  // Validate + apply the update
  const res = await validateAndApplyChannelUpdate(update, state, storeService, chainReader, externalValidation);
  if (res.isError) {
    return Result.fail(res.getError()!);
  }

  const { nextState, validUpdate, transfer, activeTransfers } = res.getValue()!;
  logger.debug(nextState, "nextState");

  // Verify at least one signature exists (and any present are valid)
  const sigRes = await validateChannelUpdateSignatures(
    nextState,
    validUpdate.aliceSignature,
    validUpdate.bobSignature,
    signer.address === state.bob ? "alice" : "bob",
  );
  if (sigRes.isError) {
    return Result.fail(
      new InboundChannelUpdateError(InboundChannelUpdateError.reasons.BadSignatures, validUpdate, nextState, {
        error: sigRes.getError().message,
      }),
    );
  }

  // Generate the cosigned commitment
  const signedRes = await generateSignedChannelCommitment(
    nextState,
    signer,
    validUpdate.aliceSignature,
    validUpdate.bobSignature,
  );
  if (signedRes.isError) {
    return Result.fail(new InboundChannelUpdateError(signedRes.getError()?.message as any, validUpdate, nextState));
  }
  const signed = signedRes.getValue();

  // Add the signature to the state
  const signedNextState = {
    ...nextState,
    latestUpdate: {
      ...nextState.latestUpdate,
      aliceSignature: signed.aliceSignature,
      bobSignature: signed.bobSignature,
    },
  };

  // Return the validated update, resultant state, double signed
  // commitment, and the transfer data
  return Result.ok({ validUpdate, nextState: signedNextState, commitment: signed, activeTransfers, transfer });
}

// This function will take in a requested update from the counterparty,
// validate it, and apply it.
// NOTE:
async function validateAndApplyChannelUpdate<T extends UpdateType>(
  counterpartyUpdate: ChannelUpdate<T>,
  previousState: FullChannelState,
  storeService: IVectorStore,
  chainReader: IVectorChainReader,
  externalValidation: IExternalValidation,
): Promise<
  Result<
    {
      validUpdate: ChannelUpdate<T>;
      nextState: FullChannelState<T>;
      activeTransfers: FullTransferState[]; // after applyUpdate
      transfer?: FullTransferState; // after applyUpdate
    },
    InboundChannelUpdateError
  >
> {
  // Create a helper to handle errors properly
  const returnError = (
    validationError: Values<typeof ValidationError.reasons>,
    state: FullChannelState = previousState,
    context: any = {},
  ): InboundValidationResult => {
    return Result.fail(
      new InboundChannelUpdateError(
        InboundChannelUpdateError.reasons.InboundValidationFailed,
        counterpartyUpdate,
        state,
        {
          error: validationError,
          ...context,
        },
      ),
    );
  };

  const { channelAddress, fromIdentifier, toIdentifier, type, nonce, balance, assetId, details } = counterpartyUpdate;
  // Get the active transfers for the channel
  const activeTransfers = await storeService.getActiveTransfers(channelAddress);

  // Perform all common update validation -- see note above
  // calling function
  // Ensure the toIdentifier is ours

  // Ensure the fromIdentifier is the counterparties

  // Ensure the nonce == previousState.nonce + 1

  // Ensure the assetId is valid

  // Perform update-type specific validation

  // You will need the final transfer balance when applying the
  // resolve update. See note in `applyUpdate`.
  let finalTransferBalance: Balance | undefined = undefined;
  // You will also need access to the stored transfer for any
  // external validation when resolving
  let storedTransfer: FullTransferState | undefined = undefined;
  switch (type) {
    case UpdateType.setup: {
      // Ensure the channelAddress is correctly generated

      // Ensure the timeout is reasonable

      // TODO: https://github.com/connext/vector/issues/51
      break;
    }

    case UpdateType.deposit: {
      // Ensure the balance has been correctly reconciled

      break;
    }
    case UpdateType.create: {
      const {
        transferId,
        transferDefinition,
        transferTimeout,
        transferInitialState,
        transferEncodings,
        meta,
      } = details as CreateUpdateDetails;
      // Ensure the transferId is properly formatted

      // Ensure the transferDefinition is properly formatted

      // If present, ensure the meta is an object

      // Ensure the transferTimeout is above the minimum

      // Ensure the transferInitialState is correctly structured

      // Ensure there is sufficient balance in the channel for the
      // proposed transfer for the appropriate asset

      // Ensure the transferEncoding is correct for the state
      // TODO: https://github.com/connext/vector/issues/51

      // Update the active transfers

      // Recreate the merkle tree

      // Ensure the merkleProofData is correct

      // Ensure the same merkleRoot is generated
      break;
    }
    case UpdateType.resolve: {
      const { transferId, transferResolver } = details as ResolveUpdateDetails;

      // Ensure transfer exists in store / retrieve for validation
      storedTransfer = await storeService.getTransferState(transferId);
      if (!storedTransfer) {
        return returnError(ValidationError.reasons.TransferNotFound);
      }

      // Ensure the transfer is active
      if (!activeTransfers.find(t => t.transferId === transferId)) {
        return returnError(ValidationError.reasons.TransferNotActive, previousState, {
          activeTransfers: activeTransfers.map(t => t.transferId).join(","),
        });
      }

      // Get the final transfer balance from contract
      const transferBalanceResult = await chainReader.resolve(
        { ...storedTransfer, transferResolver },
        previousState.networkContext.chainId,
      );

      if (transferBalanceResult.isError) {
        throw transferBalanceResult.getError()!;
      }
      finalTransferBalance = transferBalanceResult.getValue()!;

      // Ensure the transfer exists within the active transfers

      // Ensure the initiators transfer information is the same as ours:
      // - transferDefintion
      // - transferEncodings

      // Verify the balance is the same from update initiator
      // and chain service

      // Regenerate the merkle tree

      // Verify the merkle root is correct

      // If exists, verify the meta is an object
      break;
    }
    default: {
      return returnError(ValidationError.reasons.BadUpdateType);
    }
  }

  // All default validation is performed, now perform external validation
  const externalRes = await externalValidation.validateInbound(counterpartyUpdate, previousState, storedTransfer);
  if (externalRes.isError) {
    return returnError(ValidationError.reasons.ExternalValidationFailed, previousState, {
      validationError: externalRes.getError()!.message,
    });
  }

  // Apply the update
  const applyRes = await applyUpdate(counterpartyUpdate, previousState, activeTransfers, finalTransferBalance);
  if (applyRes.isError) {
    // Returns an inbound channel error, so don't use helper to preserve
    // apply error
    return Result.fail(applyRes.getError()!);
  }

  const { channel, transfer, activeTransfers: updatedActiveTransfers } = applyRes.getValue();

  return Result.ok({
    nextState: channel,
    transfer,
    activeTransfers: updatedActiveTransfers,
    validUpdate: counterpartyUpdate,
  });
}
