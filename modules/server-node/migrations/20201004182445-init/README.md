# Migration `20201004182445-init`

This migration has been generated by LayneHaber at 10/4/2020, 12:24:45 PM.
You can check out the [state of the schema](./schema.prisma) after the migration.

## Database Steps

```sql
CREATE TABLE "balance" (
    "participant" TEXT NOT NULL,
    "assetId" TEXT NOT NULL,
    "to" TEXT NOT NULL,
    "amount" TEXT NOT NULL,
    "processedDeposit" TEXT NOT NULL,
    "channelAddress" TEXT NOT NULL,

    FOREIGN KEY ("channelAddress") REFERENCES "channel"("channelAddress") ON DELETE CASCADE ON UPDATE CASCADE,
PRIMARY KEY ("participant","channelAddress","assetId")
)

CREATE TABLE "channel" (
    "channelAddress" TEXT NOT NULL,
    "publicIdentifierA" TEXT NOT NULL,
    "publicIdentifierB" TEXT NOT NULL,
    "participantA" TEXT NOT NULL,
    "participantB" TEXT NOT NULL,
    "assetIds" TEXT NOT NULL,
    "timeout" TEXT NOT NULL,
    "nonce" INTEGER NOT NULL,
    "merkleRoot" TEXT NOT NULL,
    "channelFactoryAddress" TEXT NOT NULL,
    "channelMastercopyAddress" TEXT NOT NULL,
    "chainId" INTEGER NOT NULL,
    "providerUrl" TEXT NOT NULL,
PRIMARY KEY ("channelAddress")
)

CREATE TABLE "update" (
    "channelAddress" TEXT,
    "channelAddressId" TEXT NOT NULL,
    "fromIdentifier" TEXT NOT NULL,
    "toIdentifier" TEXT NOT NULL,
    "type" TEXT NOT NULL,
    "nonce" INTEGER NOT NULL,
    "amountA" TEXT NOT NULL,
    "amountB" TEXT NOT NULL,
    "toA" TEXT NOT NULL,
    "toB" TEXT NOT NULL,
    "assetId" TEXT NOT NULL,
    "signatureA" TEXT,
    "signatureB" TEXT,
    "totalDepositedA" TEXT,
    "totalDepositedB" TEXT,
    "transferId" TEXT,
    "transferDefinition" TEXT,
    "transferTimeout" TEXT,
    "transferInitialState" TEXT,
    "transferEncodings" TEXT,
    "merkleProofData" TEXT,
    "meta" TEXT,
    "responder" TEXT,
    "transferResolver" TEXT,
    "merkleRoot" TEXT,

    FOREIGN KEY ("channelAddress") REFERENCES "channel"("channelAddress") ON DELETE SET NULL ON UPDATE CASCADE,
PRIMARY KEY ("channelAddressId","nonce")
)

CREATE TABLE "transfer" (
    "transferId" TEXT NOT NULL,
    "routingId" TEXT NOT NULL,
    "initialAmountA" TEXT NOT NULL,
    "initialAmountB" TEXT NOT NULL,
    "initialToA" TEXT NOT NULL,
    "initialToB" TEXT NOT NULL,
    "initialStateHash" TEXT NOT NULL,
    "channelAddress" TEXT,
    "channelAddressId" TEXT NOT NULL,
    "createUpdateChannelAddressId" TEXT,
    "createUpdateNonce" INTEGER,
    "resolveUpdateChannelAddressId" TEXT,
    "resolveUpdateNonce" INTEGER,

    FOREIGN KEY ("createUpdateChannelAddressId","createUpdateNonce") REFERENCES "update"("channelAddressId","nonce") ON DELETE SET NULL ON UPDATE CASCADE,
    FOREIGN KEY ("resolveUpdateChannelAddressId","resolveUpdateNonce") REFERENCES "update"("channelAddressId","nonce") ON DELETE SET NULL ON UPDATE CASCADE,
    FOREIGN KEY ("channelAddress") REFERENCES "channel"("channelAddress") ON DELETE SET NULL ON UPDATE CASCADE,
PRIMARY KEY ("transferId")
)

CREATE TABLE "event-subscription" (
    "id" TEXT NOT NULL,
    "event" TEXT NOT NULL,
    "url" TEXT NOT NULL,
PRIMARY KEY ("id")
)

CREATE TABLE "onchain-transaction" (
    "transactionHash" TEXT NOT NULL,
    "to" TEXT NOT NULL,
    "from" TEXT NOT NULL,
    "data" TEXT NOT NULL,
    "value" TEXT NOT NULL,
    "chainId" INTEGER NOT NULL,
    "nonce" INTEGER NOT NULL,
    "gasLimit" TEXT NOT NULL,
    "gasPrice" TEXT NOT NULL,
    "timestamp" INTEGER,
    "raw" TEXT,
    "blockHash" TEXT,
    "blockNumber" INTEGER,
    "contractAddress" TEXT,
    "transactionIndex" INTEGER,
    "root" TEXT,
    "gasUsed" TEXT,
    "logsBloom" TEXT,
    "logs" TEXT,
    "cumulativeGasUsed" TEXT,
    "byzantium" BOOLEAN,
    "status" TEXT NOT NULL DEFAULT 'submitted',
    "reason" TEXT NOT NULL,
    "error" TEXT,
    "channelAddress" TEXT NOT NULL,

    FOREIGN KEY ("channelAddress") REFERENCES "channel"("channelAddress") ON DELETE CASCADE ON UPDATE CASCADE,
PRIMARY KEY ("transactionHash")
)

CREATE UNIQUE INDEX "channel.publicIdentifierA_publicIdentifierB_chainId_unique" ON "channel"("publicIdentifierA", "publicIdentifierB", "chainId")

CREATE UNIQUE INDEX "channel.participantA_participantB_chainId_unique" ON "channel"("participantA", "participantB", "chainId")

CREATE UNIQUE INDEX "update_channelAddress_unique" ON "update"("channelAddress")

CREATE UNIQUE INDEX "transfer.routingId_channelAddressId_unique" ON "transfer"("routingId", "channelAddressId")

CREATE UNIQUE INDEX "transfer_createUpdateChannelAddressId_createUpdateNonce_unique" ON "transfer"("createUpdateChannelAddressId", "createUpdateNonce")

CREATE UNIQUE INDEX "transfer_resolveUpdateChannelAddressId_resolveUpdateNonce_unique" ON "transfer"("resolveUpdateChannelAddressId", "resolveUpdateNonce")

CREATE UNIQUE INDEX "event-subscription.event_unique" ON "event-subscription"("event")

CREATE UNIQUE INDEX "onchain-transaction.transactionHash_unique" ON "onchain-transaction"("transactionHash")

CREATE UNIQUE INDEX "onchain-transaction.from_nonce_unique" ON "onchain-transaction"("from", "nonce")
```

## Changes

```diff
diff --git schema.prisma schema.prisma
migration ..20201004182445-init
--- datamodel.dml
+++ datamodel.dml
@@ -1,0 +1,172 @@
+generator client {
+  provider        = "prisma-client-js"
+  previewFeatures = ["connectOrCreate"]
+  binaryTargets   = ["native"]
+}
+
+datasource db {
+  provider = ["postgresql", "sqlite"]
+  url = "***"
+}
+
+model Balance {
+  @@map(name: "balance")
+  participant      String
+  assetId          String
+  to               String
+  amount           String
+  processedDeposit String
+  Channel          Channel @relation(fields: [channelAddress], references: [channelAddress])
+  channelAddress   String
+  @@id([participant, channelAddress, assetId])
+}
+
+model Channel {
+  @@map(name: "channel")
+  channelAddress           String    @id
+  publicIdentifierA        String
+  publicIdentifierB        String
+  participantA             String
+  participantB             String
+  assetIds                 String
+  timeout                  String
+  nonce                    Int
+  merkleRoot               String
+  balances                 Balance[]
+  channelFactoryAddress    String
+  channelMastercopyAddress String
+  chainId                  Int
+  providerUrl              String
+  latestUpdate             Update
+
+  activeTransfers Transfer[]
+
+  @@unique([publicIdentifierA, publicIdentifierB, chainId])
+  @@unique([participantA, participantB, chainId])
+}
+
+model Update {
+  @@map(name: "update")
+  // COMMON PARAMS
+  channelAddress   String?
+  channel          Channel? @relation(fields: [channelAddress], references: [channelAddress])
+  channelAddressId String // required for ID so that relation can be removed
+
+  fromIdentifier String
+  toIdentifier   String
+  type           String
+  nonce          Int
+
+  // balance
+  amountA String
+  amountB String
+  toA     String
+  toB     String
+
+  assetId    String
+  signatureA String?
+  signatureB String?
+
+  // DETAILS
+  // deposit details
+  totalDepositedA String?
+  totalDepositedB String?
+
+  // create details
+  transferId           String?
+  transferDefinition   String?
+  transferTimeout      String?
+  transferInitialState String? // JSON string
+  transferEncodings    String?
+  merkleProofData      String? // proofs.join(",")
+  meta                 String?
+  responder            String?
+
+  // resolve details
+  transferResolver String?
+  merkleRoot       String?
+
+  // setup inferred from channel params
+
+  createdTransfer  Transfer? @relation("CreatedTransfer")
+  resolvedTransfer Transfer? @relation("ResolvedTransfer")
+
+  @@id([channelAddressId, nonce])
+}
+
+model Transfer {
+  @@map(name: "transfer")
+  transferId String @id
+  routingId  String
+
+  createUpdate  Update? @relation(name: "CreatedTransfer", fields: [createUpdateChannelAddressId, createUpdateNonce], references: [channelAddressId, nonce])
+  resolveUpdate Update? @relation(name: "ResolvedTransfer", fields: [resolveUpdateChannelAddressId, resolveUpdateNonce], references: [channelAddressId, nonce])
+
+  // initial balance
+  initialAmountA String
+  initialAmountB String
+  initialToA     String
+  initialToB     String
+
+  initialStateHash String
+
+  channel        Channel? @relation(fields: [channelAddress], references: [channelAddress])
+  channelAddress String?
+  channelAddressId String // required for ID so that relation can be removed
+
+  // created will always exist
+  createUpdateChannelAddressId String?
+  createUpdateNonce            Int?
+
+  // resolved will not always exist
+  resolveUpdateChannelAddressId String?
+  resolveUpdateNonce            Int?
+
+  @@unique([routingId, channelAddressId])
+}
+
+model EventSubscription {
+  @@map(name: "event-subscription")
+  id    String @id @default(uuid())
+  event String @unique
+  url   String
+}
+
+model OnchainTransaction {
+  @@map(name: "onchain-transaction")
+
+  // Response fields
+  transactionHash   String @id
+  to                String
+  from              String
+  data              String
+  value             String
+  chainId           Int
+  nonce             Int
+  gasLimit          String
+  gasPrice          String
+
+  // Receipt fields
+  timestamp         Int?
+  raw               String?
+  blockHash         String?
+  blockNumber       Int?
+  contractAddress   String?
+  transactionIndex  Int?
+  root              String?
+  gasUsed           String?
+  logsBloom         String?
+  logs              String?
+  cumulativeGasUsed String?
+  byzantium         Boolean?
+
+  // Channel fields
+  status            String @default("submitted") // no enums
+  reason            String // no enums
+  error             String?
+  channelAddress    String
+  channel           Channel @relation(fields: [channelAddress], references: [channelAddress])
+
+  @@unique(transactionHash)
+  @@unique([from, nonce])
+}
```


